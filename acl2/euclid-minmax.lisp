(in-package "RTL")
(include-book "ihs/basic-definitions" :dir :system)
(include-book "kestrel/utilities/fixbytes/instances" :dir :system)
(include-book "rtl/rel11/support/definitions" :dir :system)

(include-book "tools/with-arith5-help" :dir :system)
(local (acl2::allow-arith5-help))

(local (include-book "rtl/rel11/support/basic" :dir :system))

; info.adams.ryu.analysis.EuclidMinMax.min

(define EuclidMinMax-min-loop
  ((maximum integerp)
   (modulo integerp)
   (a integerp)
   (b integerp)
   (c integerp)
   (s integerp)
   (t_ integerp)
   (u integerp)
   (v integerp)
   (beforeLoopA booleanp))
  :measure (+ (nfix a) (nfix b))
  :returns (mv (min integerp :hyp (integerp c))
               (max integerp :hyp (and (integerp c) (integerp modulo))))
  (cond
   ((or (not (posp a)) (not (posp b))) (mv 0 0))
   ((or (and beforeLoopA (>= b a))
        (and (not beforeLoopA) (< a b) (not (= a 0))))
    (acl2::b*
     ((b-new (- b a))
      (u-new (- u s))
      (v-new (- v t_)))
     (if (>= (- u-new) maximum)
         (mv (* a c)
             (- modulo
                (* (if (> (- u-new) maximum) b b-new) c)))
       (EuclidMinMax-min-loop
        maximum modulo a b-new c s t_ u-new v-new t))))
   ((or (and beforeLoopA (< b a) (not (= b 0)))
        (and (not beforeLoopA) (>= a b)))
    (acl2::b*
     ((a-new (- a b))
      (s-new (- s u))
      (t-new (- t_ v)))
     (if (>= s-new maximum)
         (mv (* (if (> s-new maximum) a a-new) c)
             (- modulo (* b c)))
       (EuclidMinMax-min-loop
        maximum modulo a-new b c s-new t-new u v nil))))
   (t (mv 0 (- modulo c)))))

(define EuclidMinMax-min
  ((multiplier integerp)
   (modulo integerp)
   (maximum integerp))
  :returns (mv (min integerp)
               (max integerp :hyp (integerp modulo)))
  (let ((a multiplier)
        (b modulo)
        (c 1))
    (if (>= maximum b)
        (mv 0 (- modulo c))
      (EuclidMinMax-min-loop
       maximum modulo a b c 1 0 0 1 t))))

; info.adams.ryu.analysis.EuclidMinMax.max

(acl2::with-arith5-help
 (define EuclidMinMax-max-loop
  ((maximum integerp)
   (modulo integerp)
   (a integerp)
   (b integerp)
   (c integerp)
   (s integerp)
   (t_ integerp)
   (u integerp)
   (v integerp)
   (beforeLoopA booleanp))
  :measure (+ (nfix a) (nfix b))
;  :returns (mv (min integerp :hyp (integerp c))
;               (max integerp :hyp (and (integerp c) (integerp modulo))))
  (cond
   ((or (not (posp a)) (not (posp b)) (not (posp s))) (mv 0 0))
   ((or (and beforeLoopA (>= b a))
        (and (not beforeLoopA) (> b a) (not (= a 0))))
    (acl2::b*
     ((q (floor b a))
      (q (min q (- (floor (- maximum (- u)) s) 1)))
      (q (max q 1))
      (b-new (- b (* a q)))
      (u-new (- u (* s q)))
      (v-new (- v (* t_ q))))
     (if (>= (- u-new) maximum)
         (mv (* a c)
             (- modulo
                (* (if (> (- u-new) maximum) b b-new) c)))
       (EuclidMinMax-max-loop
        maximum modulo a b-new c s t_ u-new v-new t))))
   ((or (and beforeLoopA (< b a) (not (= b 0)))
        (and (not beforeLoopA) (<= b a)))
    (acl2::b*
     ((q 1)
      (q (if (= u 1)
             q
           (min q (/ (- maximum s) (+ (- u) 1)))))
      (q (max q 1))
      (a-new (- a (* b q)))
      (s-new (- s (* u q)))
      (t-new (- t_ (* v q))))
     (if (>= s-new maximum)
         (mv (* (if (> s-new maximum) a a-new) c)
             (- modulo (* b c)))
       (EuclidMinMax-max-loop
        maximum modulo a-new b c s-new t-new u v nil))))
   (t (mv 0 (- modulo c))))))

(define EuclidMinMax-max
  ((multiplier integerp)
   (modulo integerp)
   (maximum integerp))
;  :returns (mv (min integerp)
;               (max integerp :hyp (integerp modulo)))
  (let ((a multiplier)
        (b modulo)
        (c 1))
    (if (>= maximum b)
        (mv 0 (- modulo c))
      (EuclidMinMax-max-loop
       maximum modulo a b c 1 0 0 1 t))))

#|
(EuclidMinMax-min 10 33 0) ; (10 0)
(EuclidMinMax-min 10 33 1) ; (10 10)
(EuclidMinMax-min 10 33 2) ; (10 20)
(EuclidMinMax-min 10 33 3) ; (10 30)
(EuclidMinMax-min 10 33 4) ; (7 30)
(EuclidMinMax-min 10 33 5) ; (7 30)
(EuclidMinMax-min 10 33 6) ; (7 30)
(EuclidMinMax-min 10 33 7) ; (4 30)
(EuclidMinMax-min 10 33 8) ; (4 30)
(EuclidMinMax-min 10 33 9) ; (4 30)
(EuclidMinMax-min 10 33 10) ; (1 30)
(EuclidMinMax-min 10 33 11) ; (1 30)
(EuclidMinMax-min 10 33 12) ; (1 30)
(EuclidMinMax-min 10 33 13) ; (1 31)
(EuclidMinMax-min 10 33 14) ; (1 31)
(EuclidMinMax-min 10 33 15) ; (1 31)
(EuclidMinMax-min 10 33 16) ; (1 31)
(EuclidMinMax-min 10 33 17) ; (1 31)
(EuclidMinMax-min 10 33 18) ; (1 31)
(EuclidMinMax-min 10 33 19) ; (1 31)
(EuclidMinMax-min 10 33 20) ; (1 31)
(EuclidMinMax-min 10 33 21) ; (1 31)
(EuclidMinMax-min 10 33 22) ; (1 31)
(EuclidMinMax-min 10 33 23) ; (1 32)
(EuclidMinMax-min 10 33 24) ; (1 32)
(EuclidMinMax-min 10 33 25) ; (1 32)
(EuclidMinMax-min 10 33 26) ; (1 32)
(EuclidMinMax-min 10 33 27) ; (1 32)
(EuclidMinMax-min 10 33 28) ; (1 32)
(EuclidMinMax-min 10 33 29) ; (1 32)
(EuclidMinMax-min 10 33 30) ; (1 32)
(EuclidMinMax-min 10 33 31) ; (1 32)
(EuclidMinMax-min 10 33 32) ; (1 32)
(EuclidMinMax-min 10 33 33) ; (0 32)

(EuclidMinMax-max 10 33 0) ; (10 0)
(EuclidMinMax-max 10 33 1) ; (10 10)
(EuclidMinMax-max 10 33 2) ; (10 20)
(EuclidMinMax-max 10 33 3) ; (10 30)
(EuclidMinMax-max 10 33 4) ; (7 30)
(EuclidMinMax-max 10 33 5) ; (7 30)
(EuclidMinMax-max 10 33 6) ; (7 30)
(EuclidMinMax-max 10 33 7) ; (4 30)
(EuclidMinMax-max 10 33 8) ; (4 30)
(EuclidMinMax-max 10 33 9) ; (4 30)
(EuclidMinMax-max 10 33 10) ; (1 30)
(EuclidMinMax-max 10 33 11) ; (1 30)
(EuclidMinMax-max 10 33 12) ; (1 30)
(EuclidMinMax-max 10 33 13) ; (1 31)
(EuclidMinMax-max 10 33 14) ; (1 31)
(EuclidMinMax-max 10 33 15) ; (1 31)
(EuclidMinMax-max 10 33 16) ; (1 31)
(EuclidMinMax-max 10 33 17) ; (1 31)
(EuclidMinMax-max 10 33 18) ; (1 31)
(EuclidMinMax-max 10 33 19) ; (1 31)
(EuclidMinMax-max 10 33 20) ; (1 31)
(EuclidMinMax-max 10 33 21) ; (1 31)
(EuclidMinMax-max 10 33 22) ; (1 31)
(EuclidMinMax-max 10 33 23) ; (1 32)
(EuclidMinMax-max 10 33 24) ; (1 32)
(EuclidMinMax-max 10 33 25) ; (1 32)
(EuclidMinMax-max 10 33 26) ; (1 32)
(EuclidMinMax-max 10 33 27) ; (1 32)
(EuclidMinMax-max 10 33 28) ; (1 32)
(EuclidMinMax-max 10 33 29) ; (1 32)
(EuclidMinMax-max 10 33 30) ; (1 32)
(EuclidMinMax-max 10 33 31) ; (1 32)
(EuclidMinMax-max 10 33 32) ; (1 32)
(EuclidMinMax-max 10 33 33) ; (0 32)
|#
