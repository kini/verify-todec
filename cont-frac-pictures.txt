
alpha = 43/33
 = 1 + 1/(3 + 1/(3 + 1/(3)))    continued fraction
 1/1 4/3 13/10 43/33            convergents

I observe sets { frac(alpha*d) | 0 < d < n }.
In the following pictures:
* at position i means that i/33 belongs to the set
. at position i means that i/33 does not belong to the set
Mark <- means that convex hull will extend to the left in the next step
Mark -> means that convex hull will extens to the right in the next step

0 < d <  1  ................................. <->
0 < d <  2  ..........*......................  ->
0 < d <  3  ..........*.........*............  ->
0 < d <  4  ..........*.........*.........*.. <-
0 < d <  5  .......*..*.........*.........*..
0 < d <  6  .......*..*......*..*.........*..
0 < d <  7  .......*..*......*..*......*..*.. <-
0 < d <  8  ....*..*..*......*..*......*..*..
0 < d <  9  ....*..*..*...*..*..*......*..*..
0 < d < 10  ....*..*..*...*..*..*...*..*..*.. <-
0 < d < 11  .*..*..*..*...*..*..*...*..*..*..
0 < d < 12  .*..*..*..**..*..*..*...*..*..*..
0 < d < 13  .*..*..*..**..*..*..**..*..*..*.. ->
0 < d < 14  .*..*..*..**..*..*..**..*..*..**.
0 < d < 15  .*..*..**.**..*..*..**..*..*..**.
0 < d < 16  .*..*..**.**..*..**.**..*..*..**.
0 < d < 17  .*..*..**.**..*..**.**..*..**.**.
0 < d < 18  .*..**.**.**..*..**.**..*..**.**.
0 < d < 19  .*..**.**.**..**.**.**..*..**.**.
0 < d < 20  .*..**.**.**..**.**.**..**.**.**.
0 < d < 21  .**.**.**.**..**.**.**..**.**.**.
0 < d < 22  .**.**.**.***.**.**.**..**.**.**.
0 < d < 23  .**.**.**.***.**.**.***.**.**.**. ->
0 < d < 24  .**.**.**.***.**.**.***.**.**.***
0 < d < 25  .**.**.******.**.**.***.**.**.***
0 < d < 26  .**.**.******.**.******.**.**.***
0 < d < 27  .**.**.******.**.******.**.******
0 < d < 28  .**.*********.**.******.**.******
0 < d < 29  .**.*********.*********.**.******
0 < d < 30  .**.*********.*********.*********
0 < d < 31  .************.*********.*********
0 < d < 32  .**********************.*********
0 < d < 33  .******************************** <-

Exact bounds for convex hull can be described by these inequalites near <= and -> marks

frac(alpha*1) = 10/33                          ..........*......................
0 < d < 2 ==> 10/33 <= frac(alpha*d) <= 10/33  ..........*......................
frac(alpha*2) = 20/33                          ....................*............
0 < d < 3 ==> 10/33 <= frac(alpha*d) <= 20/33  ..........*.........*............
frac(alpha*3) = 10/11                          ..............................*..
0 < d < 4 ==> 10/33 <= frac(alpha*d) <= 10/11  ..........*.........*.........*..
frac(alpha*4) = 7/33                           .......*.........................
0 < d < 7 ==> 7/33  <= frac(alpha*d) <= 10/11  .......*..*......*..*......*..*..
frac(alpha*7) = 4/33                           ....*............................
0 < d < 10 ==> 4/33 <= frac(alpha*d) <= 10/11  ....*..*..*...*..*..*...*..*..*..
frac(alpha*10) = 1/33                          .*...............................
0 < d < 13 ==> 1/33 <= frac(alpha*d) <= 10/11  .*..*..*..**..*..*..**..*..*..*..
frac(alpha*13) = 31/33                         ...............................*.
0 < d < 23 ==> 1/33 <= frac(alpha*d) <= 31/33  .**.**.**.***.**.**.***.**.**.**.
frac(alpha*23) = 32/33                         ................................*
0 < d < 33 ==> 1/33 <= frac(alpha*d) <= 32/33  .********************************
frac(alpha*33) = 0                             *................................

How can it be obtained in general - iteration in recursion
Recursion is by convergents
Iteration inside convergent is by i  q[k-2]+i*q[k-1]

k=1 a[k]=3 q[k-2]=0 q[k-1]=1 q[k]=3

 0 < d <  1 ................................. is 0 < d < 1 translated by frac(alpha*(q[-1]+0*q[0]))-1
     d=1    ..........*......................                            frac(alpha*(q[-1]+1*q[0]))
 1 < d <  2 ................................. is 0 < d < 1 translated by frac(alpha*(q[-1]+1*q[0]))-1
     d=2    ....................*............                            frac(alpha*(q[-1]+2*q[0]))
 2 < d <  3 ................................. is 0 < d < 1 translated by frac(alpha*(q[-1]+2*q[0]))-1
==============================================
 0 < d <  3 ..........*.........*............ hull is [frac(alpha*q[0])..frac(alpha*(q[1]-q[0]))]
     d=3    ..............................*..           frac(alpha*q[1])=frac(alpha*(q[-1]+3*q[0]))


 0 < d <  1 .................................
     d=1    ..........*......................                            frac(alpha*(q[0]+0*q[1]))
 1 < d <  4 ....................*.........*.. is 0 < d < 3 translated by frac(alpha*(q[0]+0*q[1]))
     d=4    .......*.........................                            frac(alpha*(q[0]+1*q[1]))
 4 < d <  7 .................*.........*..... is 0 < d < 3 translated by frac(alpha*(q[0]+1*q[1]))
     d=7    ....*............................                            frac(alpha*(q[0]+2*q[1]))
 7 < d < 10 ..............*.........*........ is 0 < d < 3 translated by frac(alpha*(q[0]+2*q[1]))
==============================================
 0 < d < 10 ....*..*..*...*..*..*...*..*..*.. hull is [frac(alpha*(q[2]-q[1])),frac(alpha*q[1])]
     d=10   .*...............................           frac(alpha*q[2])=frac(alpha*(q[0]+3*q[1]))


 0 < d <  3 ..........*.........*............
     d=3    ..............................*..                             frac(alpha*(q[1]+0*q[2]))
 3 < d < 13 .*..*..*...*..*..*...*..*..*..... is 0 < d < 10 translated by frac(alpha*(q[1]+0*q[2]))-1
     d=13   ...............................*.                             frac(alpha*(q[1]+1*q[2]))
13 < d < 23 ..*..*..*...*..*..*...*..*..*.... is 0 < d < 10 translated by frac(alpha*(q[1]+1*q[2]))-1
     d=23   ................................*                             frac(alpha*(q[1]+2*q[2]))
23 < d < 33 ...*..*..*...*..*..*...*..*..*... is 0 < d < 10 translated by frac(alpha*(q[1]+2*q[2]))-1
==============================================
 0 < d < 33 .******************************** hull is [frac(alpha*q[2])..frac(alpha*(q[3]-q[2]))]
     d=33   *................................            frac(alpha*q[3])=frac(alpha*(q[1]+3*q[2]))



  Relation between contionuous fractions algorithm and Ulf Adam's minmax_euclid algorithm

Let's trace minmax_equlid algorithm on the same example a=43 b=33 alpha=43/33.
Algorithm assumes a < b, so we start from a=10 b=33. 

i a[i] b[i] s[i] u[i] t[i] v[i]   Lemma 3.5 from Ulf's paper                          Our observation
0   10   33    1    0   -1    1
1   10   23    1   -1   -1    2  0 < d <=  1 ==> 10 <= 10*d % 33 <= 10      0 < d <  2 ==> 10/33 <= frac(alpha*d) <= 10/33
2   10   13    1   -2   -1    3  0 < d <=  2 ==> 10 <= 10*d % 33 <= 20      0 < d <  3 ==> 10/33 <= frac(alpha*d) <= 20/33
3   10    3    1   -3   -1    4  0 < d <=  3 ==> 10 <= 10*d % 33 <= 30      0 < d <  4 ==> 10/33 <= frac(alpha*d) <= 30/33
4    7    3    4   -3   -5    4  0 < d <=  4 ==>  7 <= 10*d % 33 <= 30      0 < d <  7 ==>  7/33 <= frac(alpha*d) <= 30/33
5    4    3    7   -3   -9    4  0 < d <=  7 ==>  4 <= 10*d % 33 <= 30      0 < d < 10 ==>  4/33 <= frac(alpha*d) <= 30/33
6    1    3   10   -3  -13    4  0 < d <= 10 ==>  1 <= 10*d % 33 <= 30      0 < d < 13 ==>  1/33 <= frac(alpha*d) <= 30/33
7    1    2   10  -13  -13   17  0 < d <= 13 ==>  1 <= 10*d % 33 <= 31      0 < d < 23 ==>  1/33 <= frac(alpha*d) <= 31/33
8    1    1   10  -23  -13   30  0 < d <= 23 ==>  1 <= 10*d % 33 <= 32      0 < d < 33 ==>  1/33 <= frac(alpha*d) <= 32/33
9    1    0   10  -33  -13   33  0 < d <  33 ==>  1 <= 10*d % 33 <= 32      0 < d < 33 ==>  1/33 <= frac(alpha*d) <= 32/33

By the way this trace doesn't confirm this statement from the paper
"minmax_euclid returns (1,b−1) if M is greater than or equal to the multiplicative inverse of
a modulo b, i.e., M>a−1%b".
For his example the multiplicative inverse of 10 module 33 is 10 itself  10*10 % 33 = 100%33 = 1.
Let's take M=11. The minmax_euclid algorithm will stop with i=7 and return (a[7],b[7])=(1,2).
It is not (1,32).

Three hypothesis arise from this observation
1) These statements are unreachable when a<b and M<b :
  if (b[i]==0) return (1,b-1)
  if (a[i]==0) return (1,b-1)
  The algorithm will return earlier.
2) If two lines of Ulf's algorithm are changed in such a way
  if (-u[i] > M) return (a[i-1],b[i-1])
  if (s[i] > M) return (a[i-1],b[i-1])
  then it will return exact bounds instead of conservative approximation;
3) Loops A and B in Ulf's algorithm repeatedly subtract a[i+1]=a[i]-b[i] or b[i+1]=b[i]-a[i].
   If we replace these loops by division with remainder a[i+1]=a[i]%b[i] or b[i+1]=b[i]%a[i]
   we obtain our algorithm frac-alpha-d-bound-aux .
   This implies that our algorithm is only conservative approximation because it doesn't break from these loops.
I haven't proved or even tested these hypothesis yet. Just TOD.

   
   
